{
  "hash": "012455c62bc4a58c349889c449da46b6",
  "result": {
    "markdown": "# Current SDM\n\n### In this lesson, you will learn\n\n- What an SDM is\n- How to create an SDM with the machine learning method, MaxEnt\n- How to predict your SDM result onto a geographic area given current environmental variables\n\n### What is an SDM?\nA Species Distribution Model. \n\n# Install and load packages from CRAN\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"tidyverse\", repos = \"http://cran.us.r-project.org\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nInstalling package into '/Users/MilaUserAccount/Library/R/x86_64/4.2/library'\n(as 'lib' is unspecified)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThe downloaded binary packages are in\n\t/var/folders/8_/66ctd00n6b9839b2ghhk1gjw0000gp/T//RtmpZBKjmH/downloaded_packages\n```\n:::\n\n```{.r .cell-code}\ninstall.packages(\"maptools\", repos = \"http://cran.us.r-project.org\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nInstalling package into '/Users/MilaUserAccount/Library/R/x86_64/4.2/library'\n(as 'lib' is unspecified)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThe downloaded binary packages are in\n\t/var/folders/8_/66ctd00n6b9839b2ghhk1gjw0000gp/T//RtmpZBKjmH/downloaded_packages\n```\n:::\n\n```{.r .cell-code}\ninstall.packages(\"maps\", repos = \"http://cran.us.r-project.org\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nInstalling package into '/Users/MilaUserAccount/Library/R/x86_64/4.2/library'\n(as 'lib' is unspecified)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThe downloaded binary packages are in\n\t/var/folders/8_/66ctd00n6b9839b2ghhk1gjw0000gp/T//RtmpZBKjmH/downloaded_packages\n```\n:::\n\n```{.r .cell-code}\ninstall.packages(\"rJava\", repos = \"http://cran.us.r-project.org\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nInstalling package into '/Users/MilaUserAccount/Library/R/x86_64/4.2/library'\n(as 'lib' is unspecified)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThe downloaded binary packages are in\n\t/var/folders/8_/66ctd00n6b9839b2ghhk1gjw0000gp/T//RtmpZBKjmH/downloaded_packages\n```\n:::\n\n```{.r .cell-code}\ninstall.packages(\"dismo\", repos = \"http://cran.us.r-project.org\")\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nInstalling package into '/Users/MilaUserAccount/Library/R/x86_64/4.2/library'\n(as 'lib' is unspecified)\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\n\nThe downloaded binary packages are in\n\t/var/folders/8_/66ctd00n6b9839b2ghhk1gjw0000gp/T//RtmpZBKjmH/downloaded_packages\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(dismo) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: raster\n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\nLoading required package: sp\n```\n:::\n\n```{.r .cell-code}\nlibrary(maptools) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nChecking rgeos availability: FALSE\nPlease note that 'maptools' will be retired during 2023,\nplan transition at your earliest convenience;\nsome functionality will be moved to 'sp'.\n \tNote: when rgeos is not available, polygon geometry \tcomputations in maptools depend on gpclib,\n \twhich has a restricted licence. It is disabled by default;\n \tto enable gpclib, type gpclibPermit()\n```\n:::\n\n```{.r .cell-code}\nlibrary(tidyverse) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\n── Attaching core tidyverse packages ──────────────────────── tidyverse 2.0.0 ──\n✔ dplyr     1.1.0     ✔ readr     2.1.4\n✔ forcats   1.0.0     ✔ stringr   1.5.0\n✔ ggplot2   3.4.1     ✔ tibble    3.1.8\n✔ lubridate 1.9.2     ✔ tidyr     1.3.0\n✔ purrr     1.0.1     \n```\n:::\n\n::: {.cell-output .cell-output-stderr}\n```\n── Conflicts ────────────────────────────────────────── tidyverse_conflicts() ──\n✖ tidyr::extract() masks raster::extract()\n✖ dplyr::filter()  masks stats::filter()\n✖ dplyr::lag()     masks stats::lag()\n✖ dplyr::select()  masks raster::select()\nℹ Use the \u001b]8;;http://conflicted.r-lib.org/\u0007conflicted package\u001b]8;;\u0007 to force all conflicts to become errors\n```\n:::\n\n```{.r .cell-code}\nlibrary(rJava) \nlibrary(maps)\n```\n\n::: {.cell-output .cell-output-stderr}\n```\n\nAttaching package: 'maps'\n\nThe following object is masked from 'package:purrr':\n\n    map\n```\n:::\n:::\n\n\n### Obtaining and formatting occurence data\n\nFirst we need to read in our species occurence data. We will make two copies of this data. One copy is the plain data frame that we made before. Another we will convert to spatial points, which is necessary for the model later on. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nranaData <- read_csv(\"ranaData.csv\") # read the data\n```\n\n::: {.cell-output .cell-output-stderr}\n```\nNew names:\nRows: 1778 Columns: 4\n── Column specification\n──────────────────────────────────────────────────────── Delimiter: \",\" dbl\n(3): ...1, longitude, latitude date (1): eventDate\nℹ Use `spec()` to retrieve the full column specification for this data. ℹ\nSpecify the column types or set `show_col_types = FALSE` to quiet this message.\n• `` -> `...1`\n```\n:::\n\n```{.r .cell-code}\nranaDataNotCoords <- ranaData %>% dplyr::select(longitude, latitude) # copy 1\n\nranaDataSpatialPts <- SpatialPoints(ranaDataNotCoords, proj4string = CRS(\"+proj=longlat\")) # copy 2: spatial points\n```\n:::\n\n\n### Obtaining climate data\n\nWe need to obtain current climate data. We will get the bio variables from world clim at a 2.5 minute resolution. To see what each variable is, see the [worldclim website](https://www.worldclim.org/data/bioclim.html). You can see more details on this function with ?raster::getData\n\n::: {.cell}\n\n```{.r .cell-code}\ngetData(\"worldclim\", var=\"bio\", res=2.5) \n```\n\n::: {.cell-output .cell-output-stderr}\n```\nWarning in getData(\"worldclim\", var = \"bio\", res = 2.5): getData will be removed in a future version of raster\n. Please use the geodata package instead\n```\n:::\n\n::: {.cell-output .cell-output-stdout}\n```\nclass      : RasterStack \ndimensions : 3600, 8640, 31104000, 19  (nrow, ncol, ncell, nlayers)\nresolution : 0.04166667, 0.04166667  (x, y)\nextent     : -180, 180, -60, 90  (xmin, xmax, ymin, ymax)\ncrs        : +proj=longlat +datum=WGS84 \nnames      :  bio1,  bio2,  bio3,  bio4,  bio5,  bio6,  bio7,  bio8,  bio9, bio10, bio11, bio12, bio13, bio14, bio15, ... \nmin values :  -278,     9,     8,    64,   -86,  -559,    53,  -278,  -501,  -127,  -506,     0,     0,     0,     0, ... \nmax values :   319,   213,    96, 22704,   489,   258,   725,   376,   365,   382,   289, 10577,  2437,   697,   265, ... \n```\n:::\n:::\n\n\nThe data we obtained are rasters. A raster consists of a matrix of cells (or pixels) organized into rows and columns, (or a grid) where each cell contains a value representing information, such as temperature. Rasters are digital aerial photographs, imagery from satellites, digital pictures, or even scanned maps.\n\nTo read more about rasters, check out [this article](https://desktop.arcgis.com/en/arcmap/latest/manage-data/raster-and-images/what-is-raster-data.html) on arcgis. \n\nNow we will create a list of files in the climate data folder, called wc2-5. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncurrentClimList <- list.files(path = \"wc2-5/\", pattern = \".bil$\", full.names = T)\n```\n:::\n\n\nWe can take this list and create a raster stack, so we can process all the bioclim variables at one time. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncurrentClim <- raster::stack(currentClimList)\n```\n:::\n\n\nWe can check out a single layer of the data we just got. Here i'll plot bioclim 3, isothermality, and add our species occurrence data on top.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nplot(currentClim[[3]]) \nplot(ranaDataSpatialPts, add = T)\n```\n\n::: {.cell-output-display}\n![](sdm_current_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nLooks good! We have the world climate data, and our points are where we would expect them to be. \n\n### Adding background points \n\nMaxEnt requires background points, points where we do NOT have occurrence data. We will walk through the steps required to generate that here. \n\nFirst we need a raster layer to make the points up on. We can pick any of the currentClim. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nmask <- raster(currentClim[[1]]) # mask is the raster object that determines the area where we are generating pts\n```\n:::\n\n\nWe want to generate our random points reasonably nearby our occurrence points. For example, we know this frog species is only found in the US state of California, so it doesn't make sense to generate absence data on any other continent than North America. If your species is globally spread, or theoretically could be, you will need to change the details in the random points call next.\n\nWe can find the geographic extent of our data, which requires spatial points data. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ngeographicExtent <- extent(x = ranaDataSpatialPts)\n```\n:::\n\n\nWe need to generate at least 1,000 random points. We have 4000 occurrence points, so we will generate as many background points as occurrence points that we have. \n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(7536) # seed set so we get the same background points each time we run this code\n\nbackgroundPoints <- randomPoints(mask = mask, # shape we want our points generated onto \n                                 n = nrow(ranaDataNotCoords), # needs to be at least 1000\n                                 ext = geographicExtent, # our geographic extent\n                                 extf = 1.25, # how much bigger than our occ extent do we want background pts\n                                 warn = 0) # don't complain about not having a coordinate reference system\n```\n:::\n\n\nFinally, we rename the columns of our background points from x & y to longitude & latitude so they make sense in light of mapping. \n\n\n::: {.cell}\n\n```{.r .cell-code}\ncolnames(backgroundPoints) <- c(\"longitude\", \"latitude\")\n```\n:::\n\n\n### Extract the climate data for the occurrencde and background points\n\nWe need the climate data at each of our occurrence and background points so MaxEnt can figure our which environmental conditions are (or are not) associated with our species. \n\n\n::: {.cell}\n\n```{.r .cell-code}\noccEnv <- na.omit(raster::extract(x = currentClim, y = ranaDataNotCoords))\nabsenceEnv <- na.omit(raster::extract(x = currentClim, y = backgroundPoints)) \n```\n:::\n\n\n### Create data frame with presence training data and backround points (0 = abs, 1 = pres)\n\nWe need objects that contain all the data necessary to run MaxEnt: the response variable (a vector of 1s and 0s for presences and absences) and the predictor variables (the climate data associated with each occurrence or background point).\n\nCreate the response variable. \n\n::: {.cell}\n\n```{.r .cell-code}\npresenceAbsenceV <- c(rep(1, nrow(occEnv)), rep(0, nrow(absenceEnv))) \n```\n:::\n\n\nCreate the predictor variables data frame. \n\n::: {.cell}\n\n```{.r .cell-code}\npresenceAbsenceEnvDf <- as.data.frame(rbind(occEnv, absenceEnv))\n```\n:::\n\n\n### Section 4: Create SDM with Maxent\n\n# create a new folder called maxent_outputs\n\nranaSDM \\<- dismo::maxent(x = presenceAbsenceEnvDf, \\# env conditions p = presenceAbsenceV, \\# p = 1, a = 0 path = \"maxent_outputs\" )\n\n# view the maxent model by navigating in maxent_outputs folder for the html\n\nresponse(ranaSDM) \\### Section 5: Plot the Model \\### \\# clim is huge and it isn't reasonable to predict over whole world \\# first we will make it smaller predictExtent \\<- 1.25 \\* geographicExtent geographicArea \\<- crop(clim, predictExtent) \\# crop clim data to predict extent\n\nranaPredictPlot \\<- raster::predict(ranaSDM, geographicArea)\n\n# for ggplot, we need the prediction to be a data frame\n\nraster.spdf \\<- as(ranaPredictPlot, \"SpatialPixelsDataFrame\") ranaPredictDf \\<- as.data.frame(raster.spdf)\n\n# plot in ggplot\n\nwrld \\<- ggplot2::map_data(\"world\")\n\nxmax \\<- max(ranaPredictDf$x) xmin <- min(ranaPredictDf$x) ymax \\<- max(ranaPredictDf$y) ymin <- min(ranaPredictDf$y)\n\nggplot() + geom_polygon(data = wrld, aes(x = long, y = lat, group = group), fill = \"grey\") + geom_raster(data = ranaPredictDf, aes(x = x, y = y, fill = layer)) + scale_fill_gradientn(colors = terrain.colors(10, rev = T)) + coord_fixed(xlim = c(xmin, xmax), ylim = c(ymin, ymax), expand = F) + borders(\"state\") + geom_point(data = ranaDataNotCoords, aes(x = longitude, y = latitude, alpha = 0.5))\n",
    "supporting": [
      "sdm_current_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}